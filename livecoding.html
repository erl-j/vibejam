<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livecoding</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background-color: #fafafa;
            color: #1a1a1a;
            font-family: 'Times New Roman', Times, serif;
            margin: 0;
            overflow: hidden;
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            width: 100%;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: #1a1a1a;
            margin-top: -5px;
            cursor: pointer;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #ccc;
        }

        select {
            font-family: 'Times New Roman', Times, serif;
        }

        button {
            font-family: 'Times New Roman', Times, serif;
        }

        ::selection {
            background: #1a1a1a;
            color: #fafafa;
        }
    </style>
</head>

<body>
    <div id="root" style="height: 100vh; width: 100vw; display: flex; flex-direction: column;"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const apiKey = "";

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);

                this.reverbNode = this.ctx.createConvolver();
                this.reverbNode.buffer = this.createReverbBuffer(2.0);
                this.reverbGain = this.ctx.createGain();
                this.reverbGain.gain.value = 0.4;
                this.reverbNode.connect(this.reverbGain);
                this.reverbGain.connect(this.masterGain);

                this.noiseBuffer = this.createNoiseBuffer();
                this.midiAccess = null;
                this.midiOutputs = [];
                this.selectedMidiOutput = null;
                this.onMidiOutputsChange = null;
                this.initMidi();

                this.sampleCache = {};
                this.searchCache = {};
                this.activeNotes = {};
                this.activeMidiNotes = {}; // Track MIDI notes by ID: { id: { channel, pitch, offTimeout } }

                // Note event callback for visualization
                this.onNoteEvent = null;
            }

            stopNoteById(id) {
                const active = this.activeNotes[id];
                if (active) {
                    try {
                        active.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.01);
                        if (active.source && active.source.stop) {
                            active.source.stop(this.ctx.currentTime + 0.05);
                        }
                    } catch (e) { }
                    delete this.activeNotes[id];
                }
            }

            stopMidiNoteById(id) {
                const active = this.activeMidiNotes[id];
                if (active) {
                    clearTimeout(active.offTimeout);
                    const output = this.midiAccess?.outputs.get(this.selectedMidiOutput);
                    if (output) {
                        const noteOff = 0x80 | active.channel;
                        try { output.send([noteOff, active.pitch, 0]); } catch (e) { }
                    }
                    delete this.activeMidiNotes[id];
                }
            }

            registerNote(id, gain, source) {
                if (id !== undefined && id !== null) {
                    this.stopNoteById(id);
                    this.activeNotes[id] = { gain, source };
                }
            }

            parseBooleanSearch(query) {
                const tokens = [];
                let current = '';

                for (let i = 0; i < query.length; i++) {
                    const char = query[i];
                    const nextChar = i + 1 < query.length ? query[i + 1] : '';

                    if (char === '|' && nextChar === '|') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push('||');
                        i++;
                    } else if (char === '&') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push('&');
                    } else if (char === '(') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push('(');
                    } else if (char === ')') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push(')');
                    } else if (char === ' ') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                    } else {
                        current += char;
                    }
                }
                if (current.trim()) tokens.push(current.trim());

                const output = [];
                const operators = [];
                const precedence = { '||': 1, '&': 2 };

                for (const token of tokens) {
                    if (token === '&' || token === '||') {
                        while (operators.length > 0) {
                            const top = operators[operators.length - 1];
                            if (top === '(' || precedence[top] < precedence[token]) break;
                            output.push(operators.pop());
                        }
                        operators.push(token);
                    } else if (token === '(') {
                        operators.push(token);
                    } else if (token === ')') {
                        while (operators.length > 0 && operators[operators.length - 1] !== '(') {
                            output.push(operators.pop());
                        }
                        operators.pop();
                    } else {
                        output.push(token);
                    }
                }
                while (operators.length > 0) {
                    output.push(operators.pop());
                }

                return output;
            }

            async evaluateBooleanSearch(postfix) {
                const uniqueTerms = new Set();
                for (const token of postfix) {
                    if (token !== '&' && token !== '||') {
                        uniqueTerms.add(token);
                    }
                }

                const termResults = {};
                for (const term of uniqueTerms) {
                    if (!this.searchCache[term]) {
                        const res = await fetch(`http://localhost:8080/search?q=${encodeURIComponent(term)}`);
                        this.searchCache[term] = await res.json();
                    }
                    termResults[term] = this.searchCache[term];
                }

                const stack = [];
                for (const token of postfix) {
                    if (token === '&') {
                        const right = stack.pop();
                        const left = stack.pop();
                        const intersection = left.filter(l =>
                            right.some(r => r.path === l.path)
                        );
                        stack.push(intersection);
                    } else if (token === '||') {
                        const right = stack.pop();
                        const left = stack.pop();
                        const union = [...left];
                        for (const r of right) {
                            if (!union.some(u => u.path === r.path)) {
                                union.push(r);
                            }
                        }
                        stack.push(union);
                    } else {
                        stack.push(termResults[token] || []);
                    }
                }

                return stack.length > 0 ? stack[0] : [];
            }

            async loadSample(query, index) {
                const key = `${query}:${index}`;
                if (this.sampleCache[key]) return this.sampleCache[key].buffer;

                this.sampleCache[key] = { buffer: null, loading: true };

                try {
                    let results;

                    if (query.includes('&') || query.includes('||') || query.includes('(')) {
                        const postfix = this.parseBooleanSearch(query);
                        results = await this.evaluateBooleanSearch(postfix);
                        this.searchCache[query] = results;
                    } else {
                        if (!this.searchCache[query]) {
                            const res = await fetch(`http://localhost:8080/search?q=${encodeURIComponent(query)}`);
                            this.searchCache[query] = await res.json();
                        }
                        results = this.searchCache[query];
                    }

                    if (results.length === 0) {
                        console.warn(`Sample ${key}: no results found`);
                        this.sampleCache[key].loading = false;
                        return null;
                    }

                    const wrappedIndex = index % results.length;

                    const sampleInfo = results[wrappedIndex];
                    const audioRes = await fetch(`http://localhost:8080/sample?path=${encodeURIComponent(sampleInfo.path)}`);
                    const arrayBuffer = await audioRes.arrayBuffer();
                    const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);

                    this.sampleCache[key].buffer = audioBuffer;
                    this.sampleCache[key].loading = false;
                    console.log(`Loaded sample [${wrappedIndex}/${results.length}]: ${sampleInfo.name}`);
                    return audioBuffer;
                } catch (e) {
                    console.error(`Failed to load sample ${key}:`, e);
                    this.sampleCache[key].loading = false;
                    return null;
                }
            }

            playSample(buffer, time, vol, pan, reverbAmount, pitch = 60) {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = Math.pow(2, (pitch - 60) / 12);
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const revSend = this.ctx.createGain();

                source.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);
                panner.connect(revSend);
                revSend.connect(this.reverbNode);

                panner.pan.value = pan;
                revSend.gain.value = reverbAmount;
                gain.gain.value = vol;

                source.start(time);
                source.onended = () => { try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); } catch (e) { } };
            }

            async initMidi() {
                if (navigator.requestMIDIAccess) {
                    try {
                        this.midiAccess = await navigator.requestMIDIAccess();
                        this.refreshMidiOutputs();
                        this.midiAccess.onstatechange = () => this.refreshMidiOutputs();
                    } catch (e) { console.warn("MIDI Fail", e); }
                }
            }

            refreshMidiOutputs() {
                this.midiOutputs = [];
                if (this.midiAccess) {
                    for (let output of this.midiAccess.outputs.values()) {
                        this.midiOutputs.push({ id: output.id, name: output.name });
                    }
                }
                if (this.midiOutputs.length > 0) {
                    const currentExists = this.midiOutputs.some(o => o.id === this.selectedMidiOutput);
                    if (!currentExists) {
                        this.selectedMidiOutput = this.midiOutputs[0].id;
                    }
                } else {
                    this.selectedMidiOutput = null;
                }
                if (this.onMidiOutputsChange) this.onMidiOutputsChange();
            }

            setMidiOutput(id) {
                this.selectedMidiOutput = id;
            }

            getMidiOutputs() {
                return this.midiOutputs;
            }

            getSelectedMidiOutput() {
                return this.selectedMidiOutput;
            }

            setVolume(val) {
                this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.1);
            }

            createNoiseBuffer() {
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                return buffer;
            }

            createReverbBuffer(duration) {
                const sampleRate = this.ctx.sampleRate;
                const length = sampleRate * duration;
                const impulse = this.ctx.createBuffer(2, length, sampleRate);
                const left = impulse.getChannelData(0);
                const right = impulse.getChannelData(1);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 2);
                    left[i] = (Math.random() * 2 - 1) * decay;
                    right[i] = (Math.random() * 2 - 1) * decay;
                }
                return impulse;
            }

            resume() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }

            midiToFreq(m) {
                return 440 * Math.pow(2, (m - 69) / 12);
            }

            triggerKick(time, vol, pan, reverbAmount) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const revSend = this.ctx.createGain();

                osc.connect(gain); gain.connect(panner); panner.connect(this.masterGain);
                panner.connect(revSend); revSend.connect(this.reverbNode);

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time); osc.stop(time + 0.5);
                osc.onended = () => { try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); } catch (e) { } };
            }

            triggerSnare(time, vol, pan, reverbAmount) {
                const noise = this.ctx.createBufferSource(); noise.buffer = this.noiseBuffer;
                const noiseFilter = this.ctx.createBiquadFilter(); noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 1000;
                const noiseGain = this.ctx.createGain();
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain);

                const osc = this.ctx.createOscillator(); osc.type = 'triangle';
                const oscGain = this.ctx.createGain(); osc.connect(oscGain);

                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();
                noiseGain.connect(panner); oscGain.connect(panner);
                panner.connect(this.masterGain); panner.connect(revSend); revSend.connect(this.reverbNode);

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                noiseGain.gain.setValueAtTime(vol, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.frequency.setValueAtTime(100, time); oscGain.gain.setValueAtTime(vol * 0.5, time); oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

                noise.start(time); osc.start(time);
                noise.stop(time + 0.2); osc.stop(time + 0.2);
                osc.onended = () => { try { panner.disconnect(); revSend.disconnect(); noiseGain.disconnect(); oscGain.disconnect(); } catch (e) { } };
            }

            triggerHiHat(time, vol, pan, reverbAmount, open = false) {
                const source = this.ctx.createBufferSource(); source.buffer = this.noiseBuffer;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 7000;
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();

                source.connect(filter); filter.connect(gain); gain.connect(panner);
                panner.connect(this.masterGain); panner.connect(revSend); revSend.connect(this.reverbNode);

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                const duration = open ? 0.3 : 0.05;
                gain.gain.setValueAtTime(vol * 0.8, time); gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
                source.start(time); source.stop(time + duration + 0.05);
                source.onended = () => { try { panner.disconnect(); gain.disconnect(); revSend.disconnect(); } catch (e) { } };
            }

            triggerClap(time, vol, pan, reverbAmount) {
                const source = this.ctx.createBufferSource(); source.buffer = this.noiseBuffer;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 1500; filter.Q.value = 1;
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();

                source.connect(filter); filter.connect(gain); gain.connect(panner);
                panner.connect(this.masterGain); panner.connect(revSend); revSend.connect(this.reverbNode);

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                const t = time;
                gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(vol, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.1, t + 0.02); gain.gain.linearRampToValueAtTime(vol, t + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.1, t + 0.04); gain.gain.linearRampToValueAtTime(vol, t + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                source.start(time); source.stop(time + 0.25);
                source.onended = () => { try { panner.disconnect(); gain.disconnect(); revSend.disconnect(); } catch (e) { } };
            }

            triggerTom(time, vol, pan, reverbAmount, pitch = 100) {
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();
                osc.connect(gain); gain.connect(panner); panner.connect(this.masterGain);
                panner.connect(revSend); revSend.connect(this.reverbNode);
                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                osc.frequency.setValueAtTime(pitch, time); osc.frequency.exponentialRampToValueAtTime(pitch * 0.5, time + 0.2);
                gain.gain.setValueAtTime(vol, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                osc.start(time); osc.stop(time + 0.25);
                osc.onended = () => { try { panner.disconnect(); gain.disconnect(); revSend.disconnect(); } catch (e) { } };
            }

            triggerMidi(channel, pitch, vol, duration, audioTime, noteId) {
                if (!this.midiAccess || !this.selectedMidiOutput) return;
                const output = this.midiAccess.outputs.get(this.selectedMidiOutput);
                if (!output) return;

                // If this note has an ID, cancel any previous note with same ID
                if (noteId !== undefined) {
                    this.stopMidiNoteById(noteId);
                }

                const velocity = Math.min(127, Math.max(0, Math.floor(vol * 127)));
                const noteOn = 0x90 | channel;
                const noteOff = 0x80 | channel;
                const nowAudio = this.ctx.currentTime;
                const nowPerf = performance.now();
                const timeOffset = (audioTime - nowAudio) * 1000;
                const timestamp = nowPerf + Math.max(0, timeOffset);
                try {
                    output.send([noteOn, pitch, velocity], timestamp);

                    // Schedule note-off and track by ID
                    const offTimeout = setTimeout(() => {
                        try { output.send([noteOff, pitch, 0]); } catch (e) { }
                        if (noteId !== undefined) delete this.activeMidiNotes[noteId];
                    }, Math.max(0, timeOffset) + (duration * 1000));

                    if (noteId !== undefined) {
                        this.activeMidiNotes[noteId] = { channel, pitch, offTimeout };
                    }
                } catch (e) { console.error('MIDI send error', e); }
            }

            playNote(midi, time, durationSeconds, options = {}) {
                const vol = options.vol !== undefined ? options.vol : 0.5;
                const pan = options.pan !== undefined ? options.pan : 0;
                const reverbAmount = options.reverb !== undefined ? options.reverb : 0.0;
                const noteId = options.id;
                let wave = options.wave || 'sine';

                if (noteId !== undefined) {
                    this.stopNoteById(noteId);
                }

                // Emit note event for visualization
                if (this.onNoteEvent) {
                    this.onNoteEvent({
                        pitch: midi,
                        velocity: vol,
                        wave: wave,
                        duration: durationSeconds,
                        time: time
                    });
                }

                if (typeof wave === 'string' && wave.startsWith('m:')) {
                    const chStr = wave.split(':')[1];
                    let ch = parseInt(chStr); if (isNaN(ch)) ch = 1;
                    const midiCh = (ch - 1) & 0x0F;
                    this.triggerMidi(midiCh, midi, vol, durationSeconds, time, noteId);
                    return;
                }

                if (wave === 'drums') {
                    if (midi === 36 || midi === 35) this.triggerKick(time, vol, pan, reverbAmount);
                    else if (midi === 38 || midi === 40) this.triggerSnare(time, vol, pan, reverbAmount);
                    else if (midi === 39) this.triggerClap(time, vol, pan, reverbAmount);
                    else if (midi === 42 || midi === 44) this.triggerHiHat(time, vol, pan, reverbAmount, false);
                    else if (midi === 46) this.triggerHiHat(time, vol, pan, reverbAmount, true);
                    else if (midi === 41 || midi === 43 || midi === 45 || midi === 47 || midi === 48 || midi === 50) {
                        let pitch = 80; if (midi > 43) pitch = 110; if (midi > 47) pitch = 140;
                        this.triggerTom(time, vol, pan, reverbAmount, pitch);
                    }
                    else this.triggerTom(time, vol, pan, reverbAmount, 300);
                    return;
                }

                const sampleMatch = wave.match(/^([^:]+):(\d+)$/);
                if (sampleMatch) {
                    const query = sampleMatch[1];
                    const index = parseInt(sampleMatch[2]);
                    const key = `${query}:${index}`;
                    const cached = this.sampleCache[key];
                    if (cached && cached.buffer) {
                        this.playSampleWithId(cached.buffer, time, vol, pan, reverbAmount, midi, noteId, durationSeconds, options.start);
                    } else if (!cached || !cached.loading) {
                        this.loadSample(query, index);
                    }
                    return;
                }

                const cutoff = options.cutoff !== undefined ? options.cutoff : 2000;
                const attack = options.attack !== undefined ? options.attack : 0.01;
                const decay = options.decay !== undefined ? options.decay : 0.1;
                const fmIndex = options.fm || 0;

                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; filter.Q.value = options.Q || 1;
                filter.frequency.setValueAtTime(cutoff, time); filter.frequency.exponentialRampToValueAtTime(Math.max(100, cutoff * 0.1), time + durationSeconds);

                const freq = this.midiToFreq(midi); osc.frequency.setValueAtTime(freq, time);
                const modulator = this.ctx.createOscillator(); const modGain = this.ctx.createGain();
                osc.type = wave; modulator.type = 'square'; modulator.frequency.value = freq * (options.ratio || 2);
                modGain.gain.value = fmIndex * 100;

                if (fmIndex > 0) { modulator.connect(modGain); modGain.connect(osc.frequency); }
                osc.connect(filter); filter.connect(gain); gain.connect(panner);
                panner.connect(this.masterGain);
                const revSend = this.ctx.createGain(); revSend.gain.value = Math.max(0, Math.min(1, reverbAmount));
                panner.connect(revSend); revSend.connect(this.reverbNode);
                panner.pan.value = pan;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, time + Math.max(0.001, attack));
                gain.gain.exponentialRampToValueAtTime(0.001, time + durationSeconds + attack + decay);

                osc.start(time); if (fmIndex > 0) modulator.start(time);
                const stopTime = time + durationSeconds + attack + decay + 0.2;
                osc.stop(stopTime); if (fmIndex > 0) modulator.stop(stopTime);

                if (noteId !== undefined) {
                    this.activeNotes[noteId] = { gain, source: osc };
                }

                osc.onended = () => {
                    try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); } catch (e) { }
                    if (noteId !== undefined && this.activeNotes[noteId]?.source === osc) {
                        delete this.activeNotes[noteId];
                    }
                };
            }

            playSampleWithId(buffer, time, vol, pan, reverbAmount, pitch, noteId, requestedDuration, startPos) {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = Math.pow(2, (pitch - 60) / 12);
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const revSend = this.ctx.createGain();

                source.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);
                panner.connect(revSend);
                revSend.connect(this.reverbNode);

                panner.pan.value = pan;
                revSend.gain.value = reverbAmount;

                const offsetSeconds = (startPos || 0) * buffer.duration;
                const remainingDuration = (buffer.duration - offsetSeconds) / source.playbackRate.value;
                const fadeTime = 0.02;

                if (requestedDuration && requestedDuration < remainingDuration) {
                    gain.gain.setValueAtTime(vol, time);
                    gain.gain.setValueAtTime(vol, time + requestedDuration - fadeTime);
                    gain.gain.linearRampToValueAtTime(0, time + requestedDuration);
                    source.start(time, offsetSeconds, requestedDuration * source.playbackRate.value);
                } else {
                    gain.gain.value = vol;
                    source.start(time, offsetSeconds);
                }

                if (noteId !== undefined) {
                    this.activeNotes[noteId] = { gain, source };
                }

                source.onended = () => {
                    try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); } catch (e) { }
                    if (noteId !== undefined && this.activeNotes[noteId]?.source === source) {
                        delete this.activeNotes[noteId];
                    }
                };
            }
        }

        // Note name helper
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const midiToNoteName = (midi) => {
            const octave = Math.floor(midi / 12) - 1;
            const note = NOTE_NAMES[midi % 12];
            return `${note}${octave}`;
        };

        const isBlackKey = (midi) => {
            const note = midi % 12;
            return [1, 3, 6, 8, 10].includes(note);
        };

        // Get instrument display name
        const getInstrumentName = (wave) => {
            if (!wave) return 'sine';
            if (wave === 'drums') return 'drums';
            if (wave === 'sine') return 'sine';
            if (wave === 'sawtooth') return 'saw';
            if (wave === 'square') return 'square';
            if (wave === 'triangle') return 'tri';
            if (wave.startsWith('m:')) return `midi ${wave.split(':')[1]}`;
            if (wave.includes(':')) return wave.split(':')[0];
            return wave;
        };

        // Get color based on velocity (0-1)
        const getIntensityColor = (velocity, wave) => {
            const v = Math.min(1, Math.max(0, velocity));
            // Hue based on instrument type
            let hue = 0;
            if (wave === 'drums') hue = 0; // red
            else if (wave === 'sawtooth') hue = 30; // orange
            else if (wave === 'square') hue = 200; // blue
            else if (wave === 'triangle') hue = 280; // purple
            else if (wave && wave.startsWith('m:')) hue = 60; // yellow
            else hue = 120; // green for sine

            const saturation = 70 + v * 30;
            const lightness = 30 + v * 40;
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        };

        // --- PIANO VISUALIZATION COMPONENT ---
        const PianoVisualization = ({ activeNotes }) => {
            // Show 3 octaves centered around middle C (C3 to B5 = MIDI 48-83)
            const startMidi = 36;
            const endMidi = 84;
            const keys = [];

            for (let midi = startMidi; midi < endMidi; midi++) {
                keys.push(midi);
            }

            const whiteKeys = keys.filter(m => !isBlackKey(m));
            const blackKeys = keys.filter(m => isBlackKey(m));

            // Find active note for a key
            const getActiveNote = (midi) => {
                return activeNotes.find(n => n.pitch === midi);
            };

            // Calculate black key position
            const getBlackKeyPosition = (midi) => {
                const note = midi % 12;
                const octave = Math.floor(midi / 12);
                const octaveStart = octave * 12;

                // White keys before this black key in the octave
                const whiteKeysBefore = [0, 2, 4, 5, 7, 9, 11].filter(n => n < note).length;
                const totalWhiteKeysBefore = (octave - Math.floor(startMidi / 12)) * 7 + whiteKeysBefore;

                // Offset based on which black key (between C#/D, D#/E, F#/G, G#/A, A#/B)
                const offsets = { 1: -0.35, 3: 0.35, 6: -0.35, 8: 0, 10: 0.35 };
                const offset = offsets[note] || 0;

                return (totalWhiteKeysBefore - 0.5 + offset) * (100 / whiteKeys.length);
            };

            return (
                <div style={{
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    background: '#fafafa',
                    padding: '40px 20px 20px 20px'
                }}>
                    {/* Active notes display */}
                    <div style={{
                        height: '80px',
                        display: 'flex',
                        flexWrap: 'wrap',
                        gap: '8px',
                        marginBottom: '20px',
                        alignContent: 'flex-start',
                        justifyContent: 'center'
                    }}>
                        {activeNotes.map((note, i) => (
                            <div key={i} style={{
                                padding: '4px 12px',
                                background: getIntensityColor(note.velocity, note.wave),
                                color: '#fff',
                                fontSize: '14px',
                                display: 'flex',
                                gap: '8px',
                                alignItems: 'center'
                            }}>
                                <span style={{ fontWeight: 'bold' }}>{midiToNoteName(note.pitch)}</span>
                                <span style={{ opacity: 0.8 }}>{getInstrumentName(note.wave)}</span>
                            </div>
                        ))}
                    </div>

                    {/* Piano keyboard */}
                    <div style={{
                        flex: 1,
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'flex-end',
                        paddingBottom: '40px'
                    }}>
                        <div style={{
                            position: 'relative',
                            height: '180px',
                            width: '100%',
                            maxWidth: '900px',
                            display: 'flex'
                        }}>
                            {/* White keys */}
                            {whiteKeys.map((midi, i) => {
                                const active = getActiveNote(midi);
                                return (
                                    <div key={midi} style={{
                                        flex: 1,
                                        height: '100%',
                                        background: active ? getIntensityColor(active.velocity, active.wave) : '#fff',
                                        border: '1px solid #1a1a1a',
                                        marginLeft: i === 0 ? 0 : '-1px',
                                        display: 'flex',
                                        flexDirection: 'column',
                                        justifyContent: 'flex-end',
                                        alignItems: 'center',
                                        paddingBottom: '8px',
                                        transition: 'background 0.05s'
                                    }}>
                                        {active && (
                                            <span style={{
                                                fontSize: '10px',
                                                color: '#fff',
                                                textShadow: '0 0 2px rgba(0,0,0,0.5)'
                                            }}>
                                                {getInstrumentName(active.wave)}
                                            </span>
                                        )}
                                        <span style={{
                                            fontSize: '9px',
                                            color: active ? '#fff' : '#999',
                                            marginTop: '2px'
                                        }}>
                                            {midiToNoteName(midi)}
                                        </span>
                                    </div>
                                );
                            })}

                            {/* Black keys */}
                            {blackKeys.map((midi) => {
                                const active = getActiveNote(midi);
                                const left = getBlackKeyPosition(midi);
                                return (
                                    <div key={midi} style={{
                                        position: 'absolute',
                                        left: `${left}%`,
                                        width: `${60 / whiteKeys.length}%`,
                                        height: '60%',
                                        background: active ? getIntensityColor(active.velocity, active.wave) : '#1a1a1a',
                                        border: '1px solid #000',
                                        zIndex: 1,
                                        display: 'flex',
                                        flexDirection: 'column',
                                        justifyContent: 'flex-end',
                                        alignItems: 'center',
                                        paddingBottom: '4px',
                                        transition: 'background 0.05s'
                                    }}>
                                        {active && (
                                            <span style={{
                                                fontSize: '8px',
                                                color: '#fff'
                                            }}>
                                                {getInstrumentName(active.wave)}
                                            </span>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const DEFAULT_CODE = `// t: tick, s: seconds
// p: pitch, d: duration, v: volume, x: pan
// w: wave (sine, sawtooth, square, drums, m:1)

return (t, s) => {
  const notes = [];
  
  if (t % 4 === 0) notes.push({ p: 36, w: 'drums', v: 0.9 });
  if (t % 8 === 4) notes.push({ p: 38, w: 'drums', v: 0.8 });
  if (t % 2 === 0) notes.push({ p: 42, w: 'drums', v: 0.3 });

  if (t % 16 === 0) notes.push({ p: 36, d: 0.4, w: 'sawtooth', v: 0.6 });

  return notes;
};
`;

        const App = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [code, setCode] = useState(DEFAULT_CODE);
            const [error, setError] = useState(null);
            const [bpm, setBpm] = useState(120);
            const [volume, setVolume] = useState(0.3);
            const [currentTick, setCurrentTick] = useState(0);
            const [isLiveLinked, setIsLiveLinked] = useState(false);
            const [midiOutputs, setMidiOutputs] = useState([]);
            const [selectedMidiOutput, setSelectedMidiOutput] = useState(null);
            const [activeNotes, setActiveNotes] = useState([]);

            const engineRef = useRef(null);
            const userFuncRef = useRef(null);
            const workerRef = useRef(null);
            const nextNoteTimeRef = useRef(0);
            const tickCounterRef = useRef(0);
            const scheduleAheadTime = 0.1;

            useEffect(() => {
                const workerCode = `
                    let intervalId = null;
                    self.onmessage = function(e) {
                        if (e.data === 'start') {
                            intervalId = setInterval(() => self.postMessage('tick'), 25);
                        } else if (e.data === 'stop') {
                            clearInterval(intervalId);
                            intervalId = null;
                        }
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                workerRef.current = new Worker(URL.createObjectURL(blob));
                return () => {
                    workerRef.current?.terminate();
                };
            }, []);

            useEffect(() => {
                let evtSource;
                const connectLiveLink = () => {
                    evtSource = new EventSource("http://localhost:8080/events");
                    evtSource.onmessage = (e) => {
                        try {
                            const data = JSON.parse(e.data);
                            setCode(data.code);
                            setIsLiveLinked(true);
                        } catch (err) { console.error(err); }
                    };
                    evtSource.onerror = () => {
                        setIsLiveLinked(false);
                        evtSource.close();
                        setTimeout(connectLiveLink, 2000);
                    };
                    evtSource.onopen = () => setIsLiveLinked(true);
                };
                connectLiveLink();
                return () => evtSource?.close();
            }, []);

            useEffect(() => {
                engineRef.current = new AudioEngine();
                engineRef.current.onMidiOutputsChange = () => {
                    setMidiOutputs([...engineRef.current.getMidiOutputs()]);
                    setSelectedMidiOutput(engineRef.current.getSelectedMidiOutput());
                };

                // Set up note event callback for visualization
                engineRef.current.onNoteEvent = (note) => {
                    setActiveNotes(prev => {
                        const now = Date.now();
                        const duration = (note.duration || 0.1) * 1000 + 100;
                        const newNote = { ...note, startTime: now, endTime: now + duration };
                        return [...prev.filter(n => n.endTime > now), newNote];
                    });
                };

                setTimeout(() => {
                    if (engineRef.current) {
                        setMidiOutputs([...engineRef.current.getMidiOutputs()]);
                        setSelectedMidiOutput(engineRef.current.getSelectedMidiOutput());
                    }
                }, 500);
                return () => engineRef.current?.ctx?.close();
            }, []);

            // Clean up expired notes periodically
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setActiveNotes(prev => prev.filter(n => n.endTime > now));
                }, 50);
                return () => clearInterval(interval);
            }, []);

            useEffect(() => engineRef.current?.setVolume(volume), [volume]);

            useEffect(() => {
                try {
                    const createFunction = new Function(code);
                    const userFunc = createFunction();
                    if (typeof userFunc === 'function') {
                        userFuncRef.current = userFunc;
                        setError(null);
                    } else { throw new Error("Code must return a function."); }
                } catch (e) { setError(e.message); }
            }, [code]);

            const scheduleNote = (tickNumber, time) => {
                if (userFuncRef.current && engineRef.current) {
                    try {
                        const notes = userFuncRef.current(tickNumber, time);
                        const secondsPerTick = (60.0 / bpm) / 4.0;
                        if (Array.isArray(notes)) {
                            notes.forEach(n => {
                                const midi = n.p || 60; const dur = n.d || 0.1; const offsetTicks = n.o || 0;
                                const noteTime = time + (offsetTicks * secondsPerTick);
                                const opts = { vol: n.v, attack: n.a, reverb: n.r, cutoff: n.c, wave: n.w || n.wave, fm: n.f || n.fm, ratio: n.ratio, pan: n.x, id: n.id, start: n.start };
                                engineRef.current.playNote(midi, noteTime, dur, opts);
                            });
                        }
                    } catch (e) { console.error(e); }
                }
            };

            const scheduler = useCallback(() => {
                if (!engineRef.current) return;
                while (nextNoteTimeRef.current < engineRef.current.ctx.currentTime + scheduleAheadTime) {
                    scheduleNote(tickCounterRef.current, nextNoteTimeRef.current);
                    nextNoteTimeRef.current += (60.0 / bpm) / 4.0;
                    tickCounterRef.current++;
                }
                if (tickCounterRef.current % 4 === 0) {
                    setCurrentTick(tickCounterRef.current);
                }
            }, [bpm]);

            useEffect(() => {
                if (!workerRef.current) return;
                workerRef.current.onmessage = () => {
                    if (isPlaying) scheduler();
                };
            }, [isPlaying, scheduler]);

            const togglePlay = () => {
                if (isPlaying) {
                    workerRef.current?.postMessage('stop');
                    setIsPlaying(false);
                    setActiveNotes([]);
                } else {
                    if (engineRef.current.ctx.state === 'suspended') engineRef.current.ctx.resume();
                    tickCounterRef.current = 0;
                    nextNoteTimeRef.current = engineRef.current.ctx.currentTime + 0.05;
                    setIsPlaying(true);
                    workerRef.current?.postMessage('start');
                }
            };

            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
                    {/* Header */}
                    <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        padding: '16px 24px',
                        borderBottom: '1px solid #ddd'
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '24px' }}>
                            <span style={{ fontSize: '18px', letterSpacing: '0.1em' }}>livecoding</span>

                            <button
                                onClick={togglePlay}
                                style={{
                                    padding: '8px 20px',
                                    background: isPlaying ? '#1a1a1a' : '#fff',
                                    color: isPlaying ? '#fff' : '#1a1a1a',
                                    border: '1px solid #1a1a1a',
                                    cursor: 'pointer',
                                    fontSize: '14px'
                                }}
                            >
                                {isPlaying ? "stop" : "play"}
                            </button>

                            {isLiveLinked && (
                                <span style={{ fontSize: '12px', color: '#666' }}>linked</span>
                            )}

                            <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', width: '100px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#666' }}>
                                    <span>bpm</span><span>{bpm}</span>
                                </div>
                                <input type="range" min="60" max="200" value={bpm} onChange={(e) => setBpm(Number(e.target.value))} />
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', width: '100px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#666' }}>
                                    <span>vol</span><span>{Math.round(volume * 100)}%</span>
                                </div>
                                <input type="range" min="0" max="1" step="0.01" value={volume} onChange={(e) => setVolume(Number(e.target.value))} />
                            </div>

                            {midiOutputs.length > 0 && (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                    <span style={{ fontSize: '11px', color: '#666' }}>midi</span>
                                    <select
                                        value={selectedMidiOutput || ''}
                                        onChange={(e) => {
                                            setSelectedMidiOutput(e.target.value);
                                            engineRef.current?.setMidiOutput(e.target.value);
                                        }}
                                        style={{
                                            background: '#fff',
                                            border: '1px solid #ccc',
                                            padding: '4px 8px',
                                            fontSize: '12px'
                                        }}
                                    >
                                        {midiOutputs.map(o => (
                                            <option key={o.id} value={o.id}>{o.name}</option>
                                        ))}
                                    </select>
                                </div>
                            )}
                        </div>

                        <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                            {error && (
                                <span style={{ fontSize: '12px', color: '#c00' }}>{error}</span>
                            )}
                            <span style={{ fontSize: '12px', color: '#999' }}>tick {currentTick}</span>
                        </div>
                    </div>

                    {/* Piano visualization */}
                    <PianoVisualization activeNotes={activeNotes} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>